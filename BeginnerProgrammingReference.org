#+TITLE: Beginning Programming in JavaScript
#+AUTHOR: Clarissa Littler
#+OPTIONS: toc:nil
#+LaTeX_HEADER: \usepackage{color}
#+LaTeX_HEADER: \usepackage{framed}
#+LaTeX_HEADER: \usepackage{minted}
#+LaTeX_HEADER: \newcommand{\key}[1]{\textcolor{blue}{#1}}

* Meta								   :noexport:
  Starting words: [2016-05-25 Wed] 7962
  Ending words: 8697
                8878
* todos 							   :noexport:
** TODO Fix the sections on how to run code in the browser
* Introduction
** What Is This Document?
   This document is a part of a set of tutorial lectures for absolute beginners to learn programming. The mini-course is centered around JavaScript and on accomplishing certain small goals in JavaScript. 

** What This Document Isn't
   1. A full course on JavaScript
   2. An explanation of how to do web-programming
   3. A reference for the entire JavaScript language
** Why Programming?
   First, let's talk about why someone would even want to learn computer programming in the first place. There's the obvious pragmatic reason of hoping to get a job as a programmer. There's also all the things you can potentially /do/ as a programmer. These days we talk a lot about coding websites and mobile apps, which are massively important in their own right, but there's even more beyond that. In just the last few years we've reached a point where we can programmatically control the electronics in our houses, we can write code to control 3D printers, we can program AIs and robots and self-driving vehicles. A larger and larger portion of our lives is going to be mediated by code and automation, and since I have a strong populist streak I'd love to see more people be able to take control of this dependence on automation and artificial intelligence.

   Even beyond all of those good reasons for learning programming, there's also just the pleasure of it. Coding can be a lot like cooking or any other form of crafting: you're figuring out how to make something and just the act of /making/ brings a certain pleasure with it.
** What Is Programming?
   Before we start talking about /how/ to program, we need to discuss /what/ programming is. The answer I think I lot of people would give is something like "programming is how you tell a computer to do things", which is true but I think we can go a little deeper than that by taking a detour through what "computer" and "computation" really mean. 

   Once upon a time, by which I mean the first half of the twentieth century, "computer" was a job title not a noun. A computer was a person who made calculations, often for physics experiments or firing solution tables for the military. In other words, computers were people whose job was to /perform computation/. As a historical side-note, computers were mostly women and these computers, in turn, were some of the first programmers. 

   Computers, whether people or machines, perform computations by executing a series of steps. Think back to how you learned to add big numbers together with a pencil and paper: you start at the rightmost column, add the two numbers together, carry the one if you need to, and proceed to the next column. In fact, every calculation you learned how to do in math classes all had some series of steps you were supposed to do to get the answer. 

   We can generalize this idea of taking steps and calculations to be about more than just numbers. Any procedure that takes
   + a finite[fn:1] number of steps 
   + a finite amount of "material"
   + a finite amount of time to complete 
can be described as a computation. This includes things like
   + cooking
   + following a map
   + building furniture from a wordless diagram

And while tasks like these might seem like a bit of a digression when we're talking about /computers/, the point here is that anything that *can* be described in the "finite" way we did above can potentially be done by programmed machine. Self-driving cars can follow map directions to get to a destination. 3D printers can assemble solid objects given a blue print and enough material. 

Computation is not just number crunching or showing you a webpage. Now, you might be wondering what /can't/ be described by a computation, and it turns out the answer is "quite a lot, but not a lot you'd care about". You're most likely to run into the limits of computation when writing programs that try to analyze other programs. This is why there's no perfect anti-virus program: it's physically impossible for there to be a program that can look at another program and determine, with perfect accuracy, whether or not its a virus. I'm not joking when I say "physically impossible". The limits of computation are as real and physical as the laws of motion. No amount of making computers faster can get around them. 

The difference between a recipe and a "program" is the level of precision. A recipe can be short, to the point, and you can fill in the gaps because you're a person and you have experience you can draw on to make conclusions, to read between the lines. A computer doesn't have that ability. It needs instructions to be absolutely precise, to be 100% clear with no ambiguity. Writing in English, or any other natural language, isn't precise enough to be certain that you're telling the machine what you *think* you're telling it. 

Because of this, programming languages tend to be small and with a very rigid, non-extensible grammar. The same way that in any language we speak there's a notion of "correct" and "incorrect" grammar, there's correct and incorrect grammar for a programming language. Unlike a natural language, where I can speak my native tongue of Texan and say "y'all'd've" and you probably know what I mean. Spend five minutes on tumblr and you'll see new idioms and words being coined constantly. It's really cool! Programming languages don't generally have this flexibility, though. Their grammar is set. 

Instead, we have specialized, simple, languages for exactly describing what the computer should do. Unsurprisingly, we call these /programming languages/. There's many, many programming languages out there and some are good, some are bad, but most are just /different/ ways of describing computations to the computer. For this course, we'll be specifically learning a language called JavaScript.
** Why JavaScript?
   In this mini-course we'll be learning JavaScript. Why JavaScript in particular, though? First, JavaScript is the language that makes interactive websites *work*. Now, if your first thought is "what's a non-interactive site?" then I suggest you try looking at one of the GeoCities archive projects to see what 90s web pages looked like. They were ugly and they were basically just static text, images, and links. Nothing changed when you interacted with it. The only real points of interaction were forms and links.

   Obviously, that's nothing what websites look like now. We have animations as you hover over and click things. We have pages that change constantly as you're interacting with them. We even have rich games that can run in the browser. All of that is possible because we now have the ability to run code that creates this interactive experience. All of the code that runs in your web browser is in JavaScript.

   Why? Well, like most things related to programming language adoption it's a matter of someone deciding to use it and eventually everyone else settling on the ready solution rather than inventing their own. The end result, though, is that every browser that exists, whether on a phone, or a laptop, or a desktop, or a tablet all have what's called an /interpreter/ that can understand JavaScript programs and run them in order to make the page your own interactive. We'll talk more later about /what/ happens in your browser when you visit a webpage.

   Suffice it to say, JavaScript is a ubiquitous and important language now.

   Luckily, I happen to also think it's a fairly decent one. If you look online for people's opinions on JavaScript you'll find it gets some hate because there are some pretty weird and counterintuitve aspects of the language, but they're also mostly avoidable unless you're running into someone else's code that uses them. "JavaScript: The Good Parts" by Crockford is a good reference for the nice, clean core of the language. 

* Basic Syntax and Translation
** Loading and Running Code
*** meta 							   :noexport:
    Include three things here:
    1. how to open the javascript console in the browser and run lines of code
    2. how to run a javascript program in the browser
    3. how to install and run a javascript program through node
** Nouns and Verbs
   The same way that, in English, there's nouns that describe objects and verbs that describe actions, in a programming language there's a distinction between the "nouns" that describe data and the "verbs" that describe what to do with the data. 

   Data in a programming language are going to be things like numbers, pieces of text called strings, lists of things, and collections of things. 

   The actions in a programming language are things like reading in user input, printing out messages, changing the webpage, changing data, and storing data. There's even more complicated constructs to do things multiple times or to even store code so it can be reused again and again. 
** Descriptions vs. Algorithms
   We've established that programs are detailed descriptions of instructions that are human readable but precise enough for a computer to understand.

   There is a connection, though, between the ways we describe things to each other versus how we need to describe tasks to a computer. 

   For the rest of these notes we'll be explaining how to take a description of how to perform a task in English and translate it into JavaScript. There are going to be keywords that are important clues in how we take an English solution and turn it into real code. We'll highlight these keywords when we first introduce them by having them show in the color \textcolor{blue}{blue}.

   Our first example is that whenever we say \textcolor{blue}{print} something, we know that in JavaScript this is going to turn into =console.log(thing-to-print)=. So whenever you see in a description such as 

#+BEGIN_CENTER
Compare two numbers, =a= and =b=, and then print the value of the larger number.
#+END_CENTER

You know that you're going to use =console.log= to print out something.
*** meta							   :noexport:
    In this section we need to explain the idea that we'll be introducing syntax by explaining how informal phrases will lead to syntax
** Running Code By Hand
   The last bit of prologue before we start describing the JavaScript language is that throughout this document we'll be explaining how to evaluate code /by hand/ if you wish to. 

   Now, that might seem an odd thing to do but it's a lot like learning arithmetic as a child. There's nothing wrong with using a calculator *once you know how it works*. First, though, you need to understand what the calculator is doing under the hood. Not even because it "builds character", but because unless you know how to do calculations yourself on some level you won't know how to spot what a right answer and a wrong answer looks like and you won't have the skills to double check calculations. 

   It's easy to make typos and say something you didn't mean even entering things into a calculator and it's far easier still to say something you didn't mean at all when you're programming a computer. It's a useful skill to be able to check your code before you ever even run it. 

   To this end, with each new piece of JavaScript we introduce we'll explain how to evaluate the code by hand with a pen and paper. You don't have to format the paper the way I suggest, just as long as it's clear to you what the state of the progrma is.
*** meta 							   :noexport:
    In this section we need to include explanation of the fact that you can run code by yourself with just a pen and paper if you wish. Why? Because it's a good way to get experience with writing code and ensures that you understand what's really happening.
** Basic Expressions
*** Expressions and Values 
  In JavaScript, and a number of languages, there's a distinction between steps in a program and calculations that result in some kind of value. By calculations I mean things such as 
   + concatenating strings
   + adding numbers
   + printing values
  Most expressions will return some kind of /value/. By /value/ I mean the basic data of JavaScript: numbers are values, pieces of literal text are values, lists are values, and other kinds of data we'll end up seeing. There's even a value called /undefined/ that's the value that corresponds to "this expression didn't return anything useful", which might seem odd at first but it's similar to the way the number 0 is the quantity of "no quantity".
*** Numbers
     The first kind of data we'll look at are /numbers/. Numbers in JavaScript are just like numbers in math classes you took. The operations you're familiar with are all here: multiplication, division, addition, and subtraction. 

     In JavaScript, the symbols are pretty similar to what you may have seen before
     #+ATTR_LATEX: :align |l|l|
     |----------------+--------|
     | name           | symbol |
     |----------------+--------|
     | addition       | $+$    | 
     | subtraction    | $-$    |
     | division       | $/$    |
     | multiplication | $*$    |
     |----------------+--------|

     If you type in something like ~10*(3-2)+5~ into the console you'll see the JavaScript interpreter /evaluate/ the expression and then return the value, which in this case is 15.

     Go ahead and try a few arithmetic expressions just to see what happens.
**** Evaluation by hand
     This is our very first example of how to evaluate code *by hand*. Now, there's two pieces here that are important. The base numbers in JavaScript, the /literals/ as they're often called in programming, just evaluate to themselves: the number =4= becomes the value 4, the number =0= becomes the value 0.

     You can test that yourself in the JavaScript console by just entering numbers and seeing that the /value/ returned is just the number you entered. 

     The arithmetic expressions evaluate in the normal order of operations[fn:2]
*** Strings
     One of the other incredibly important kinds of data are /strings/. Strings are pieces of text held within quotation marks, either double or single quotes. A programming language needs strings so that it can interact with text: either reading and understanding it or displaying it to the user. 

 You can make a string either like
#+LaTeX: \begin{framed}
 #+BEGIN_SRC js :exports code
   "this is a string, or should I say 'a string'"
 #+END_SRC
#+LaTeX: \end{framed}
 or like this
#+LATEX: \begin{framed}
 #+BEGIN_SRC js :exports code
   'this is a string, or should I say "a string"'
 #+END_SRC
#+LaTeX: \end{framed}
 but there's a few things that /aren't/ valid. You can't do 
#+LATEX: \begin{framed}
 #+BEGIN_SRC js :exports code
   "this is a string, or should I say "a string""
 #+END_SRC
#+LATEX: \end{framed}

 because since you started the string with a double-quote its not obvious to the interpreter where you wanted the end of the string to be. If you want to represent quotations-within-strings you should really just switch between single and double quotes.

 This also means that it isn't valid to mis-match the kinds of quotation marks. So something like
#+LATEX: \begin{framed}
 #+BEGIN_SRC js :exports code
   "this is a string'
 #+END_SRC
#+LATEX: \end{framed}
 will not work.

     The most primitive operation on strings is the ability to /concatenate/ text. Concatenate really just means "stick together" and, in JavaScript is /also/ represented by the =+= symbol. If you enter something like
     #+LATEX: \begin{framed}
     #+BEGIN_SRC js :exports code 
       "this is one string" + " this is another string"
       + " and together we are..."
     #+END_SRC
     #+LaTeX: \end{framed}

     You will see "this is one string this is another string and together we are..." as one string. Now, you'll notice that we needed to put /space/ at the beginning of " this is another string" and " and together we are..." in order for their to be a space between the pieces of the sentence. We could also have just as easily written
     #+LATEX: \begin{framed}
     #+BEGIN_SRC js :exports code
       "this is one string " + "this is another string "
       + "and together we are..."
     #+END_SRC
     #+LATEX: \end{framed}
because all that matters is that the spaces are /somewhere/.

Leaving out spaces is a *very* common mistake, so get in the habit of paying attention to the spaces at the beginning or end of the string.
**** Evaluation by hand
     Strings evaluate to themselves, so the a valid string such as 
     #+BEGIN_SRC js :exports code
     "my dog is named chicken"     
     #+END_SRC
     evaluates to the /value/ "my dog is named chicken"

     String concatenation is evaluated by combining the two strings, being careful to not add any extra space.
** Statements and Steps
   One of the first things we need to discuss before we begin writing real programs is how to do more than a single step in a program. 

   We've already seen two basic kinds of expressions: we've seen numeric and string /literals/, where the thing you type *is* the value, and basic arithmetic operations that evaluate to a number just the way you'd expect. 

   Real programs, just like real directions, have many /steps/. These steps in JavaScript are called /statements/. Statements are *generally* separated by semi-colons (*;*), though not always. We'll be explicit about where they are unnecessary. [fn:3]

   Any expression can be put on a line by itself, like this
   #+LATEX: \begin{framed}
   #+BEGIN_SRC js :exports code :tangle statementsExample.js
     10;
     20;
     "lalalala";
   #+END_SRC
   #+LaTeX: \end{framed}

   but simple expressions don't really do anything. A more /interesting/ expression that we looked at in the opening was =console.log=. We'll still delay a bit in explaining *why* =console.log= works the way it does, but we'll use it at the JavaScript console to print things out. The following simple program just prints out the numbers 1,2,3 in succession. 

   #+LATEX: \begin{framed}
   #+BEGIN_SRC js :exports code :results output :tangle consoleLogTest.js
     console.log(1);
     console.log(2);
     console.log(3);
   #+END_SRC
   #+LaTeX: \end{framed}

#+BEGIN_SRC html :exports none :tangle consoleLogTest.html
  <!doctype html>
  <html>
    <head>
      <script src="consoleLogTest.js">
      </script>
    </head>
    <body>
      Open the JavaScript console and see what happened!
    </body>
  </html>
#+END_SRC


If you point your browser to the file =consoleLogTest.html=, which includes the above code as a script, and then open up the console you should see the numbers 1,2,3 printed out. 
*** Evaluating by hand
    To evaluate a sequence of statements, just evaluate each statement in turn in the order they appear down the page.

** Variables
   Now that we know how to do more than a single thing at a time, we need to deal with how data is stored and used later. In essentially every programming language we have some notion of /variables/. 

    Variables are something we're all familiar with in our speech in general. Have you ever heard a story where someone says "I have a friend, let's call her Anna, ...". For the rest of the story you know that "Anna" is the speaker's friend, even if that's not her real name. The name Anna "points" to the person.

    Similarly, we have /pronouns/ in English. We can say "he" or "him" and, if we've already established who "he" is, then you know who the "variable" points to. For example, in the sentence "Bob has three hats. He wears two of them each day." you know that "he" is Bob of the three hats.

    Variables are the pronouns of a programming language. We make them like 
    #+LATEX: \begin{framed}
    #+BEGIN_SRC js :exports code
      var thisIsAVariable = 20;
    #+END_SRC
    #+LaTeX: \end{framed}

    where =var= is the start of the expression that tells JavaScript that you are /declaring/ a variable, the name "thisIsAVariable" is the actual name of the variable, the /pronoun/ you're making, and the expression to the right of the equals sign is the going to be evaluated to give the value the variable /pointing/ at.

    If you consider the English sentence "She waved at Anna, and she waved back" you'll notice that "she" means two different people within the same sentence. Similarly to English pronouns, in a programming language variables are allowed to refer to, to point to, different things at different times.

    The act of making a variable refer to a piece of data is called /assignment/ and we say that you're /assigning the variable/.

    Assigning the variable has the following form
    #+LATEX: \begin{framed}
    #+BEGIN_SRC js :exports code
      thisIsAVariable = "assigning a string instead";
    #+END_SRC
    #+LaTeX: \end{framed}

    In this case, we're assigning a string to =thisIsAVariable=. 

    You might wonder if it's possible to do /declare/ a variable without /assigning/ it and, in fact, you can
    #+LATEX: \begin{framed}
    #+BEGIN_SRC js :exports code
      var thisIsntAssigned;
    #+END_SRC
    #+LaTeX: \end{framed}
    But this is like starting a conversation with "He says hi!". You have no idea who /he/ is at the start and the person, or computer, you're talking to is just going to be confused. Now, you can clarify who /he/ is by assigning a value later in the "conversation" but it's generally best to assign something to a variable when it's declared. 
*** What can you name variables?
    You might be wondering what variables can be named. While technically the rules are slightly broader than this, I recommend variables to use just letters when possible, starting with a lower case letter, and using alternate casing when a variable name is multiple words.

    Now, some folks like to say you should give variables really long descriptive names like =howFarTheMisslesShouldGo= but I think it's good enough to give them a name that's distinctive and memorable such as =missleDist= for the /dist/ance the missles should go. I personally find very long multi-word names make it harder to skim code effectively.
*** Evaluating by hand    
    To evaluate variables by hand, first create a small two-column table on your paper with the headings "names" and "values". Fill the first column with the names of all the variables you see declared in the program and leave the second column empty for now. [fn:4]

    Then, when you come to the line of a variable declaration, evaluate the expression to the right of the equals sign, if any, and fill in the value in the corresponding spot of the table. If there is no expression when the variable is declared, put =undefined= in the table instead.

    When you assign a variable, evaluate the expression to the right of the equals sign then change the value in the table corresponding to the variable.

    Finally, when a variable is /referenced/, just look up the value of the variable in the table and return that value.
** Arrays
   In every day life, we use /lists/ constantly: todo \key{lists}, grocery \key{lists}, email \key{lists}, even your Facebook friends or Twitter followers is, in some sense, a general \key{list} of things. 

   More generally, the concept of a \key{list} describes everything from a hastily made scrawling of directions to general containers of thigns like bookshelves and clothes racks.

   The key features are that there is an /order/ to the elements of the "list", a beginning and an end, and there's a way to retrieve and replace what's in different spots in the "list", much like how you can grab a book from the middle of a bookcase and put a book in another spot later. In this generalized list you don't have to worry about the size per se the way you would with a bookcase. You can keep adding items to the list, wherever you want in the list.
   
   These lists in JavaScript are called arrays and they're the first kind of compound container that we'll see in JavaScript. In JavaScript, we make arrays by putting expressions between square brackets and separated by commas as in =[1,3,"thing"]=. This example gives us an array that has three items in it: these three "slots" are numbered /starting with zero/ [fn:5]. More explicitly, we have that =1= is stored in the 0th place in the array, =3= is stored in the 1st place in the array, and \verb+"thing"+ is stored in the 2nd place in the array.
   
   In JavaScript, we can retrieve items from the array with the "square bracket" syntax as in the following example
   #+LaTeX: \begin{shaded}
   #+BEGIN_SRC js :exports code :results output
     var arr = [1,3,"thing"];
     console.log(arr[0]);
     console.log(arr[1]);
     console.log(arr[2]);
   #+END_SRC
   #+LaTeX: \end{shaded}

   In other words, we take 
   1. the name of the array (=arr=)
   2. open square bracket (=[=)
   3. the number corresponding to the place, or \key{index}, in the array (=0=)
   4. a closing square bracket (=]=)

*** meta							   :noexport:
    Lessons that need to be in this section
    1. arrays function as lists in JavaScript
    2. arrays can have different /kinds/ of data
       * but is this even a thing that mostly needs to be pointed out for people who think in terms of "types"
     1. How would you represent a user account for a social media site /as an object/?
     2. How would you represent a car /as an object/ in a racing game?
** Objects
   In everyday life we have things like contact lists, directories, dictionaries, and glossaries. These are all kinds of data that map \key{names} to some kind of /information/.

   All these general concepts of mapping are capture in JavaScript by /objects/. Objects are simply collections of names and values. We generally call the names /properties/.

   You can make an object by including a list of pairs of names and expressions, separated by commas
   #+LaTeX: \begin{framed}
   #+BEGIN_SRC js :exports code
     { name1 : 1, name2 : 2, name3 : "3"}
   #+END_SRC
   #+LaTeX: \end{framed}

   The colons between the names and values are important.

   Once you have your data in an object, you can access the data two different ways. The first one is what people call the "dot syntax". It works like

   #+LaTeX: \begin{framed}
   #+BEGIN_SRC js :exports code
     var ourObject = {name1 : 10, name2 : "thing"};
     console.log(ourObject.name1);
   #+END_SRC
   #+LaTeX: \end{framed}

   where to /get/ the value connected to =name1= in the object =ourObject=, we put a dot between =ourObject= and =name1=. There's no quotation marks needed. In this way object properties are much like variables: they are names that refer to values.

   The other way you can refer to the properties of an object are with the "bracket syntax", where you put the name of the property *in quotes* and inside a pair of brackets instead. Our example above becomes,

   #+LaTeX: \begin{framed}
   #+BEGIN_SRC js :exports code
     var ourObject = {name1 : 10, name2 : "thing"};
     console.log(ourObject["name1"]);
   #+END_SRC
   #+LaTeX: \end{framed}
*** Why "object"?
    The name object might seem a bit odd, but there's some intution for it.

    First, think about how you might want to represent a physical /object/ like a table in a computer program. If you want to represent a table in, say, a game then you probably only care about a few things about it such as
    1. the table's location
    2. the table's dimensions
    3. the table's color

 These attributes you care about are the table's /properties/ and a collection of all of this data is the representation of a table as an object.
**** Exercises
** Choices
    Often when we're discussing instructions there's a notion of /choice/. \key{If} it's raining, take an umbrella. \key{If} you see the purple Little Free Library, take a right, \key{otherwise} you should keep walking. \key{If} the avocados are ripe, make tacos.

    We can make these choices in programming as well. \key{If} the username and password match, log the user in. \key{If} the user clicks send, send the email. 
*** Booleans
    In order to make these choices, though, we need for the programming language to understand what it means for something to be "true".

    While truth is a pretty complicated concept if you ask a philosopher, for the purposes of basic programming it's quite simple: there is a kind of data called a /boolean/. Booleans are either ~true~ or ~false~. In order to make decisions, we need operations and functions that will return booleans. 

    For example, we have the equality operator, ~===~, and the less than operator ~<~, and the greater than operator ~>~. These operations follow our intuitive notions of what they should mean. ~2 < 5~ is true, but ~2 === 5~ is false.

    We also have operations /on/ booleans such as \key{or} (=||=), \key{and} (=&&=), and \key{not} (=!=) that represent logical operations. The or operation (=a||b=) is true whenever =a= is true *or* =b= is true or both are true. The and operation =a&&b= is true /only/ when =a= is true *and* =b= is true. The not operation =!a= is true only when =a= is false.

    These correspond to how we make decisions. \key{If} you're hungry \key{and} you have a snack, \key{then} eat it. \key{If} you're \key{not} bored, keep working. \key{If} you have a date or it's been more than a month, \key{then} shower.
**** Truthy and falsy
     JavaScript's notion of booleans is slightly more flexible than most programming languages. You can actually use any kind of data like booleans. All data in JavaScript is either /truthy/, or is treated like the boolean =true= in operations, or it is =falsy= and is treated like =false=.
**** Evaluation by hand
     Both =true= and =false= are literals, just like basic strings and numbers, and they evaluate to the values =true= and =false= respectively.

     The boolean operations =&&=, =||=, and =!= are operators summarized below.
***** Boolean operations on Booleans
     And:

     #+attr_latex: :align |l|l|l|
     |------------+------------+--------|
     | argument 1 | argument 2 | result |
     |------------+------------+--------|
     | true       | true       | true   |
     | true       | false      | false  |
     | false      | true       | false  |
     | false      | false      | false  |
     |------------+------------+--------|

     Or:

     #+attr_latex: :align |l|l|l|
     |------------+------------+--------|
     | argument 1 | argument 2 | result |
     |------------+------------+--------|
     | true       | true       | true   |
     | true       | false      | true   |
     | false      | true       | true   |
     | false      | false      | false  |
     |------------+------------+--------|


     Not:

     #+attr_latex: :align |l|l|
     |----------+--------|
     | argument | result |
     |----------+--------|
     | true     | false  |
     | false    | true   |
     |----------+--------|
***** Boolean operations in general
     We've skipped over an important detail about how the boolean operations =||= and =&&= work: something often called "shortcircuiting evaluation".

     If you'll notice back at the tables in our previous [[*Evaluation by hand][section]] then you'll see that if the /first/ argument to =||= evaluates to true (or a truthy value), then we don't /need/ to evaluate the second argument to =||= to know that the expression will evaluate to =true=. In fact, JavaScript (and most languages) won't evaluate the second argument to =||= if the first argument is true. If you type the following code into the console
     #+LaTeX: \begin{framed}
     #+BEGIN_SRC js :exports code :results output
       5 || console.log(10);
     #+END_SRC
     #+LaTeX: \end{framed}

     You should just get the number =5= without the number =10= being printed out. 

     Similarly, you'll see that for =&&= that the second argument only /needs/ to be evaluated if the first argument is false or falsey.

     Thus we can summarize the tables more generally as
     
     =a && b=:
      #+attr_latex: :align |l|l|l|
     |--------+-------------+--------|
     | a      | b           | result |
     |--------+-------------+--------|
     | truthy | evaluated   | b      |
     | falsey | unevaluated | a      |
     |--------+-------------+--------|


      =a || b=:
     #+attr_latex: :align |l|l|l|
     |--------+-------------+--------|
     | a      | b           | result |
     |--------+-------------+--------|
     | truthy | unevaluated | a      |
     | falsey | evaluated   | b      |
     |--------+-------------+--------|

     =! a=
     #+attr_latex: :align |l|l|
     |----------+--------|
     | a        | result |
     |----------+--------|
     | truthy   | false  |
     | falsey   | true   |
     |----------+--------|      
*** If-statements
    As you can imagine from the way I've been emphasizing the word "if", it's somehow important to the syntax of making choices.

    We call these "if-statements", and we use them like
#+BEGIN_SRC js :exports code
  if (2 < 5) {
      console.log("two is less than five");
  }
#+END_SRC

If-statements are the first exception we've seen to the rule that all-statements end with a semi-colon.

What if you have alternatives in mind: code that you want to run if the condition /isn't true/? In that case you need the keyword ~else~, as in
#+BEGIN_SRC  js :exports code
  if (2 === 5) {
      console.log("two is equal to five");
  }
  else {
      console.log("two wasn't equal to five");
  }
#+END_SRC

If you have complicated conditions you can even chain if-else statements like
#+BEGIN_SRC js :exports code
  var thing = 10;

  if (thing > 20) {
      console.log("print one thing");
  }
  else if (thing < 0) {
      console.log("print another thing");
  }
  else {
      console.log("THE THING");
  }
#+END_SRC

**** Evaluation by hand
     To evaluate an if-statement of the form
#+LaTeX: \begin{framed}
#+BEGIN_SRC js :exports code
  if(condition){
      ...
  }
  else {
      ...
  }
#+END_SRC
#+LaTeX: \end{framed}
first evaluate the condition. If it is /truthy/, execute the code in the body of the if-clause and, when you're done, move onto the next statement after the if-statement. If the condition is /falsy/, then evaluate the code inside the else-clause and, when you're done, move onto the next statement after the if-statement. If there's no else-clause, then simply move onto the next statement if the condition is falsy.

If you're evaluating a if-else-chain of the form
#+LaTeX: \begin{framed}
#+BEGIN_SRC js :exports code
  if (condition1) {
          ...
  }
  else if (condition2) {
          ...
  }
      ...
  else {
        
  }
#+END_SRC
#+LaTeX: \end{framed}     

Evaluate each 
**** Explaining shortcircuiting evaluation with if-statements

** Repetition
Very often, there are /subtasks/ when we're performing a task. We need to do something again and again. This repetition has a couple of obvious forms and a more subtle one.
The two obvious ones are

   1. doing something a /number/ of times
   2. doing something until there's some change

and the more subtle one is /naming/ actions so that you can perform them again and again as a sequence of steps.

*** For-loops
    
For the first kind of repetition think of times you've said or heard instructions like, 
   + cut \key{three} onions
   + put \key{every} book on the shelf
   + send a letter to \key{each} address on the list

When the instruction lists either a number of times to perform an action or specifies a collection of /things/ that you need to act on. Both of these are going to be handled in JavaScript with what are called *for loops*.

The basic structure of a for-loop is something like  
#+LaTeX: \begin{framed}
#+BEGIN_SRC js :exports code
  for(var i=0; i < 10; i = i+1){
      console.log(i);
  }
#+END_SRC
#+LaTeX: \end{framed}

where you have 
  1. the JavaScript keyword =for=, followed by three semi-colon separated things in parentheses:
     1. the initialization of a variable to be used to count (~var i =0~)
     2. how you know when you're done (=i < 10=)
     3. what the next step should be (~i = i+1~)
  2. the body of the function (=console.log(i)=) in braces

Putting all these pieces together, what's your guess about what this code does?
*** While-loops
*** Defining and calling unctions
**** meta							   :noexport:
     The point of the defining functions is that you can re-use code more than once in a program.
     The informal idea is that when you have a sub-task in your algorithm, such as "cracking an egg" or  
* Closures and Scope
** Inner and outer functions
  What happens when we define a function /inside/ another function?

  We've talked a little about variables and scope. To review, we know that when you /execute/ a function you are creating a new scope, or "variable table", that, whenever you use a variable, is checked before all the other scopes that are in play. Much of the time, this new scope is no longer used after you exit the function, but there's one case where it can live on indefinitely: when you have an /inner/ function that you return as a value. 

  This is a consequence of JavaScript's scoping rules, which say that the place you look for the value of a variable is defined by where the variable is located in the /text/ of the program. This is called /lexical/ scoping. That's a bit abstract so let's look at a few examples.

  First, here's a simple example. In the following program a function is defined and called: what value will it print out?

  #+LaTeX: \begin{framed}
  #+BEGIN_SRC js :exports code :results output
    var number = 0;

    function testFunction () {
        var number = 20;
        console.log(number);
    }

    testFunction();
  #+END_SRC

  #+RESULTS:
  : 20

  #+LaTeX: \end{framed}

  If you test this yourself you'll see that it prints /20/ because when you call the function, you create a /new/ variable named =number= in the *new* scope of the function and when you use the variable =number= in the =console.log= call, you look up the value in the new scope and find the value of 20.

What about a slightly more complicated example? Instead of defining a function that prints, we define a function that *returns* a function that prints. What value does this program print out now?

  #+LaTeX: \begin{framed}
  #+BEGIN_SRC js :exports code :results output 
    var number = 0;

    function testFunction () {
        var number = 20;
        return function () {
            console.log(number);
        }
    }

    var fun = testFunction();

    fun();
  #+END_SRC

  #+RESULTS:
  : 20

  #+LaTeX: \end{framed}

  It /still/ prints out 20! You might think that when we call =fun()= at the bottom of the program the code
  #+BEGIN_SRC js :exports code
    function () {
        console.log(number);
    }
  #+END_SRC
  would look at the value at the /global/ scope, not the scope of =testFunction=. Languages that do that are called /dynamically/ scoped. Instead, JavaScript, as a /lexically/ scoped language looks at what the =number= would have pointed to at the time the function was /defined/. 

Meanwhile, if we print out =console.log(number)= at global scope we'll print out the number 0 instead of 20.

Further, variables defined in the outer function are /only/ visible to the inner function. If we try an example such as 

  #+LaTeX: \begin{framed}
  #+BEGIN_SRC js :exports code
    function outerFun () {
        var thing = "I'M HIDDEN";
        return function () {
            return thing;
        }
    }

    var thinger = outerFun();

    console.log(thinger());
    console.log(thing);
  #+END_SRC

  #+LaTeX: \end{framed}

Then we'll 

  For example, if you navigate to the file =counterExample.html=, which runs the following code

  #+LaTeX: \begin{framed}
  #+BEGIN_SRC js :results output :exports code :tangle counterExample.js
    function outer () {
        var counter = 0;
        return function (){
            counter = counter + 1;
            console.log(counter);
        }
    }

    inc = outer();

    inc();
    inc();
    inc();
  #+END_SRC
 

  #+RESULTS:
  : 1
  : 2
  : 3

 #+LaTeX: \end{framed}


#+BEGIN_SRC html :exports none :tangle counterExample.html
  <!doctype html>

  <html>
    <head>
      <script src="counterExample.js"></script>
    </head>
  <body>
  <h1>Open the console and see what happened</h1>
  </body>
  </html>
#+END_SRC

you can see that the number the function =inc= prints out changes each time, because the variable =counter= which was defined in the scope of the =outer= function is still being referred to by the body of the function defined inside =outer=.

#+LaTeX: \begin{framed}
As an exercise, try running through this example by hand. Keep in mind the rules of scope for inner functions.
#+LaTeX: \end{framed}

We call a function like =inc= that can refer to variables "hidden" from normal view a /closure/.

** Closures and objects
   Closures become even more useful once we combine them with objects. For example, let's say we want to represent a counter as an object like
   #+BEGIN_SRC js :exports code
     var counter = { value : 0,
                     inc : function () {
                         counter.value = counter.value + 1;
                         return counter.value;
                     },
                     dec : function () {
                         counter.value = counter.value - 1;
                         return counter.value;
                     }
                   }
   #+END_SRC

but there's a slight problem with object. You can just change the =value= property to whatever you want by setting the property as normal as in the following example
#+BEGIN_SRC js :exports code
  counter.value = "thing";
#+END_SRC
which means that if later in your program you call =counter.inc= then you'll get a rather unexpected result: 
#+BEGIN_SRC js :exports results :results output
  var counter = { value : 0,
                  inc : function () {
                      counter.value = counter.value + 1;
                      return counter.value;
                  },
                  dec : function () {
                      value = value - 1;
                      return counter.value;
                  }
                };

  counter.value = "thing";
  counter.inc();
  console.log(counter.value);
#+END_SRC

#+RESULTS:
: thing1

* Advanced Iteration
** meta								   :noexport:
   In this section we need to talk about mapping and .forEach functions and things like that that are useful and getting to be very idiomatic, though they require a bit more complicated understanding of higher-order functions to get them right.  
* Appendix: Evaluating Code By Hand
** General Rules and Setup for Interpreting a Program
   First, mark down a box labeled "current line". Every step you take, make a note of what line you're on.

   You'll start at the first line of the program and, unless some rule specifies otherwise, go to the /next/ line of code after you're finished with each line.

   Also make a special section labled "output", which you'll use every time something is written to the console by the program.

   If a line of code is an expression *only*, evaluate the expression as normal then *throw away* the return value of the expression.
*** Variable declaration     
Look at your program. For all of the instances you see of ~var name~ or ~var name = expression~ (that isn't in the body of a function (and if you haven't seen functions yet, don't worry)), make a table that looks like

     | name1 | name2 | name3 | name4 | ... |
     |       |       |       |       |     | 

 It should have one column for each variable name. 

 You don't actually fill anything *in* to start, instead if there's a ~= expression~ portion of the variable declaration you wait until the line in question is reached before filling in the entry in the table according to the rules of the assignment expression.
** Expressions
   If an *expression* is the only thing on the line, evaluate the expression according to the appropriate rules for that expression.
*** Arithmetic
    Numbers evaluate to themselves. Arithmetic operations evaluate exactly according to their  them to: ~+~ is addition, ~-~ is subtraction, etc.
*** Strings
    Strings evaluate to themselves. The ~+~ operator "concatenates" two strings together.
*** Booleans
    ~true~ evaluates to ~true~, ~false~ evaluates to ~false~. 

    The boolean operator ~!~ takes an expression. Evaluate ~! exp~ by first evaluating the expression ~exp~. If it returns a truthy value, then return ~false~. If it returns a falsy value, then return ~true~.

    The short-circuiting operators ~&&~ and ~||~ have special rules. ~exp1 && exp2~ is evaluated by first evaluating ~exp1~, if it is truthy then evaluate ~exp2~ and return its value. If it is falsy, then return the value of ~exp1~.

    ~exp1 || exp2~ is evaluated by first evaluating ~exp1~. If it is truthy then return the value of ~exp1~. If it is falsy then evaluate ~exp2~ and return its value.

    As a reminder, falsy values are ~NaN~, ~null~, ~undefined~, ~0~, ~""~, and ~false~. Everything else is truthy.
*** Assignment
    Assignment is always of the form ~name = expression~. First, you evaluate the expression based on the kind of expression it is, then fill whatever value it returns *into* the appropriate entry in the table.
     
    The value you wrote into the table is also the value returned by the expression.

*** Output to console
    For purposes of "being the interpreter", we're going to treat the function ~console.log~ as a special operation. When you see an expression of the form ~console.log(exp)~, evaluate the expresion that is the argument, then write the value in the output column you've set aside. As an expression, ~console.log~ returns ~undefined~. 
*** typeof
    The ~typeof~ operator takes an /expression/ as an argument. Evaluate this expression is and return, as a string, the type of the value returned according to the following rules
    + numbers return "number"
      + this includes ~NaN~ and ~Infinity~
    + strings return "string"
    + undefined returns "undefined"
    + objects return "object"
    + booleans return "boolean"
*** Variables resolution
    To evaluate a variable, you have to first consider where the variable's ~var~ statement is and you then you examine the corresponding table that you made. If there is an overlap in names between two tables that are both visible from a point in the code, precedence goes to the more recently created table.
*** Function calls
    A function is called when it is passed zero or more arguments. For example, ~fun()~, ~fun(1)~, ~fun(1,2)~, etc. are all valid function calls.

    A function call is evaluated by:
    1) substituting the passed in values for the arguments of the function, which means everywhere the formal argument was seen in the function body, rewrite it to be the corresponding value
    2) evaluate the body like you would a new program
       1) make a variable table
       2) evaluate each statement sequentially
       3) if there is a return statement, then *stop* executing the function, go back to the point of where the function was called and hand back the value of the expression passed to the ~return~
       4) if there is no return statement by the end of the function, return ~undefined~

**** A caveat on variable tables for functions
     After exiting the function, if there is nothing else that can reference the function's local variable table, then you may erase the table.

     If, on the other hand, that table is still visible to some entity in the program, you may *not* erase it and must keep the variable table in play.
** Object specific expressions
*** General object layout
 An object is represented as a table a list of pairs of 
    + a property name
    + the value corresponding to the property

*** Objects and variables
    An important note about variables and objects. A variable never holds a literal object. Instead, what the variable contains is an "arrow" that points to the object. The "value" of an object is, then, simply the pointer rather than the object itself.

    The implication of this is that there's no 
    
*** Object creation with new
    Objects can be created using the ~new Constr()~ syntax. This is evaluated by
    1. creating a new object
    2. setting the ~.constructor~ property to the constructor function
    3. running the constructor function with ~this~ bound to the new object
    4. returning *a pointer to* the new object after the constructor function finishes running

    An object created with the ~{}~ or ~{ prop : val, prop : val, ...}~ syntax is equivalent to an object created using ~new Object()~ that then has the corresponding properties, if any, set.
*** Object property access and assignment
    An object's properties can be accessed through two methods: the "dot" syntax ~obj.prop~ or the "array" syntax ~obj["prop"]~. These are evaluated identically, the only distinction is the names that are allowed to be used for the properties: the array syntax is far more permissive with allowed names. 

    You evaluate property access by looking up the value of the property in the object and returning it. If the property isn't in the table corresponding to the object, first check the prototype of the constructor of the object. If the property isn't in the prototype or the prototype's prototype etc., then return undefined. When searching for a property, the first place you find it takes precedence and you return with *that value* immediately and do not continue searching up the prototype tree.

    You evaluate property *assignment* by first evaluating the expression to the right of the ~=~ and putting that value into the table corresponding to the object, making a new space for the property if there isn't already one in the object.
*** this
     The statement ~this~ acts like a variable with special evaluation rules. There's two different ways in which ~this~ can be used
     1) in the constructor of an object
     2) in a function to be called *by* an object

In the first case, when ~new Cons()~ is called to make a new object using the constructor ~Cons~, ~this~ is a reference to the fresh object that is being constructed. See also the section on object creation.

In the second case, when a function is called *as a method*, ~this~ points to the parent object. 

If ~this~ is encountered outside of these two cases, then it resolves to the "global object" of the program.
** For loops
    A basic for loop has the form
    #+BEGIN_SRC js :exports code
      for (initialization; condition_for_continuing; next_step){
          statement1;
          statement2;
          statement3;
          ...
      }
    #+END_SRC
It's not *strictly* required, but you should make the "initialization" code only be of the form ~var name = exp~ or ~name = exp~. The condition for continuing the loop should be an expression that returns a boolean. The next step slot should be an assignment expression that modifies the variable named in the initialization.

The rule is that you 
   1) execute the code in the "initialization" slot
   2) evaluate the condition for continuing
      1) if it is truthy, go to step (3)
      2) if it falsey, jump to the line of code *after* the end of the for loop
   3) execute the statements in the for loop
   4) execute the code in the "next step" part of the for loop
   5) go to step (2)
** While loops
    A while loop has the form
    #+BEGIN_SRC js :exports code
      while (condition){
          statement1;
          statement2;
          statement3;
          ...
      }
    #+END_SRC
The rule is that you
   1) evaluate the condition
      1) if it is truthy, go to step (2)
      2) if it is falsey, jump to the line of code *after* the end of the while loop
   2) execute the statements in the while loop
   3) go to step (1)

** If statements
    If statements have the basic form
    #+BEGIN_SRC js :exports code
      if (condition){
          statement1;
          statement2;
          ...
      }
      else {
          morestatement1;
          morestatement2;
          morestatement3;
      }
    #+END_SRC
    The rule for them is that you

    1) evaluate the condition
       1) if it is truthy, perform the statements listed between the braces of the "if"
       2) if it is falsy, perform the statements listed between the braces of the "else"
    

The other form of if-statement is to leave out the ~else~ branch. In this case, our rule reads

    1) evaluate the condition
       1) if it is truthy, perform the statements listed between the braces of the "if"
       2) if it is falsy, do nothing
  
** Function declarations
    There are two function declarations. There is the *expression* form which has the following syntax 
    #+BEGIN_SRC js :exports code
      function (arg1, arg2, ...) {
          statement1;
          statement2;
          statement3;
      }
    #+END_SRC
 This evaluates to a function value, which in our pen and paper we'll represent as a box that
    + contains the list of arguments to the function
    + the lines of code for the body of the function
    + an arrow pointing to the variable table within which the function was defined (this is important for calling functions!)

The second kind of function declaration, which is a *statement*, is the named function declaration, which has the following syntax.
    #+BEGIN_SRC js :exports code
      function name (arg1,arg2,arg3) {
          statement1;
          statement2;
          statement3;
      }
    #+END_SRC

You evaluate this by treating it as equivalent to 
#+BEGIN_SRC js :exports code
  var name = function (...){
     ...
  };
#+END_SRC

* Appendix: Numbers That Aren't Numbers
** When is a number not a number?
   When is a number not a number? When it's /not a number/! Now that sounds like some kind of bad joke, but there is actually a "number" called =NaN=, which stands for "not a number", in JavaScript. This "number" is how JavaScript denotes that at some point a numerical calculation /went wrong/, for example if you type the expression \verb+3 / "chicken"+ into the console then you'll get back =NaN=. You may have already discovered it if you tried something that is ill-defined mathematically such as =0/0=.
     
   Once you're trapped in =NaN= land you can't get back out again. 

   #+LaTeX: \begin{leftbar}
   Try typing the following expressions into the console just to see what happens:
   1. =NaN + NaN=
   2. =NaN * 0=
   3. =1 + NaN=
   #+LaTeX: \end{leftbar}
** Infinity
   The other odd number you might encounter in JavaScript is =Infinity=. =Infinity= is the "number" you get when you perform an operation such as dividing a non-zero number by zero, such as =1/0=.

   Now, as you might expect a number of operations on =Infinity= still yield =Infinity=. For example,
   #+LaTeX: \begin{leftbar}
   1. =0 + Infinity=
   2. =Infinity - 10=
   3. =Infinity * 2=
   4. =Infinity / 0=
   #+LaTeX: \end{leftbar}
   will all output =Infinity=, but =Infinity*0= is going to be =NaN=.
** Why have these?   
   In day-to-day programming, you won't encounter these pseudo-numbers very often. They're much like =undefined= in that their use is to signal that /something went wrong/, but instead of =undefined= which could be the result of many different kinds of errors, =Infinity= and =NaN= have very particular causes involving numeric operations.

   The fact that JavaScript is so nice about dividing by zero is somewhat rare. An older programming language such as C or C++ has "undefined behavior" when dividing by zero, which means that you can't rely on your program behaving predictably when this error happens.
** Evaluation By Hand
 =Nan= and =Infinity= evaluate to themselves. Any numeric operation involving =NaN= will result again in =NaN=. Any numeric operation on =Infinity=, other than multiplying by =0=, will give back =Infinity=.
* Footnotes

[fn:5] This is called "0-indexing" and is almost universal in computer science. If you do any amount of programming you'll start unconciously counting things starting with the "0th" item.

[fn:4] Technically speaking this isn't *quite* how JavaScript works, because of something called /variable hoisting/ where declarations are evaluated, but that's an advanced topic and one that you shouldn't run into as long as you always /declare/ your variables /before/ using them.

[fn:3] Technically there's many places where you *could* leave semi-colons out, but it's generally a bad habit. Why? Because it generally leads to very /strange/ error messages when something goes wrong. Anything that makes your code harder to debug is generally a bad idea.

[fn:2] Please Excuse My Dear Aunt Sally
 
      | Please | Parentheses    |
      | Excuse | Exponent       |
      | My     | Multiplication |
      | Dear   | Division       |
      | Aunt   | Addition       |
      | Sally  | Subtraction    |

[fn:1] Finite means a quantity that can be held, measured, stored. Infinite means that it's too big to be held.
